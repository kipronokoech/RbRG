# -*- coding: utf-8 -*-
"""RGR_orphan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C-5l9Cuhm-7iLNxyra3Oee_pLTCp4SOU
"""

import cv2 as cv
import numpy as np

def RGR_orphan(img_array):
    # Read the image you want connected components of
    #src = cv.imread(img,0)
    # Threshold it so it becomes a binary image
    img_array=img_array.astype(np.uint8)
    img_array=cv.cvtColor(img_array,cv.COLOR_RGB2GRAY)
    ret, thresh = cv.threshold(img_array,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU) 
    connectivity = 8
    # Perform the operation
    output = cv.connectedComponentsWithStats(thresh, connectivity)
    # Get the results
    # The first cell is the number of labels
    nb_components = output[0]
    # The second cell is the label matrix
    output2 = output[1]
    # The third cell is the stat matrix
    stats = output[2]
    # The fourth cell is the centroid matrix
    centroids = output[3]
    #your answer  stats[1:, -1]
    sizes = stats[1:,-1]; nb_components = nb_components - 1
    l=int(len(sizes)/1.8)
    min_size=(np.mean(np.sort(sizes)[1:l]))
    #for every component in the image, you keep it only if it's above min_size
    #your answer image
    img2 = np.zeros((output2.shape))
    #for every component in the image, you keep it only if it's above min_size
    for i in range(0, nb_components):
        if sizes[i] >= min_size:
            img2[output2 == i + 1] = 255
    return img2
